@{
    ViewData["Title"] = "Home Page";
}
@section Styles {
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }

        h1, h2 {
            color: #333;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            background-color: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
        }

        ul {
            padding-left: 20px;
        }

        .example, .explanation {
            background-color: #fff;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .code {
            background-color: #2d2d2d;
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: "Courier New", monospace;
            overflow-x: auto;
        }

        .code pre {
            margin: 0;
        }

        .real-life {
            margin-top: 30px;
            background-color: #f9f9f9;
            padding: 15px;
            border-left: 5px solid #27ae60;
        }

        .real-life h3 {
            margin-top: 0;
        }

        .list-item {
            margin-bottom: 10px;
        }

        .callout {
            background-color: #eafaf1;
            padding: 10px;
            border-left: 4px solid #27ae60;
            margin-top: 20px;
        }
    </style>
}
<h1>Fluent Interface Design Pattern Explained</h1>

<div class="section">
    <h2>What the Fluent Interface Design Pattern Does</h2>
    <p>
        The <strong>Fluent Interface Design Pattern</strong> is a way of designing APIs to provide a more readable and natural style of code. Methods are structured to return the current instance of the object, allowing method chaining and making the code look more like a conversation.
    </p>
</div>

<div class="section">
    <h2>Problem it Solves</h2>
    <ul>
        <li class="list-item"><strong>Improved Readability</strong>: By enabling method chaining, it reduces verbosity and makes the code easier to read.</li>
        <li class="list-item"><strong>Natural Flow</strong>: Complex configuration or setup steps can be written in a sequential and logical flow.</li>
        <li class="list-item"><strong>Conciseness</strong>: Removes the need for repetitive object references, simplifying multi-step processes.</li>
    </ul>
</div>

<div class="section">
    <h2>How It Works</h2>
    <p>
        In the Fluent Interface Pattern, each method in a class returns the same instance of the class, enabling multiple methods to be called in a single statement. This pattern is often used in builders, DSLs (Domain-Specific Languages), and query APIs.
    </p>
</div>

<div class="section">
    <h2>Real-life Example</h2>
    <div class="real-life">
        <h3>Restaurant Menu Ordering</h3>
        <p>
            Imagine ordering a custom burger at a restaurant. You specify each ingredient step-by-step in a natural flow:
        </p>
        <ul>
            <li class="list-item"><strong>Add Bread</strong>: You start by choosing the type of bread.</li>
            <li class="list-item"><strong>Add Ingredients</strong>: You sequentially add lettuce, tomato, cheese, etc.</li>
            <li class="list-item"><strong>Add Sauce</strong>: Finally, you specify the sauce you want.</li>
        </ul>
        <p>The system processes this fluent order flow and constructs your burger as specified.</p>
    </div>
</div>

<div class="section">
    <h2>Fluent Interface Pattern in Code</h2>
    <p>The Fluent Interface Pattern can be implemented in code like this:</p>

    <div class="example">
        <p><strong>Code Example:</strong></p>
        <div class="code">
            <pre>
public class BurgerBuilder {
    private string bread = "Default Bread";
    private List<string> ingredients = new List<string>();
    private string sauce = "Default Sauce";

    public BurgerBuilder AddBread(string breadType) {
        this.bread = breadType;
        return this;
    }

    public BurgerBuilder AddIngredient(string ingredient) {
        this.ingredients.Add(ingredient);
        return this;
    }

    public BurgerBuilder AddSauce(string sauceType) {
        this.sauce = sauceType;
        return this;
    }

    public void Build() {
        Console.WriteLine($"Burger with {bread}, {string.Join(", ", ingredients)}, and {sauce} is ready!");
    }
}

public class Program {
    public static void Main(string[] args) {
        new BurgerBuilder()
            .AddBread("Sesame Seed Bun")
            .AddIngredient("Lettuce")
            .AddIngredient("Tomato")
            .AddIngredient("Cheese")
            .AddSauce("BBQ Sauce")
            .Build();

        // Output: Burger with Sesame Seed Bun, Lettuce, Tomato, Cheese, and BBQ Sauce is ready!
    }
}
            </pre>
        </div>
    </div>
</div>

<div class="section callout">
    <h2>Benefits of the Fluent Interface Pattern</h2>
    <ul>
        <li class="list-item"><strong>Improved Readability</strong>: Code looks clean, concise, and natural.</li>
        <li class="list-item"><strong>Chaining</strong>: Multiple operations can be combined into one statement.</li>
        <li class="list-item"><strong>Natural Flow</strong>: Encourages a step-by-step process that mirrors real-world logic.</li>
        <li class="list-item"><strong>Flexibility</strong>: Easy to extend for additional operations.</li>
    </ul>
</div>

<div class="section">
    <h2>Conclusion</h2>
    <p>
        The Fluent Interface Design Pattern is ideal for creating APIs or DSLs that are user-friendly and easy to read. It simplifies complex processes by presenting a logical flow of chained methods, making it a powerful tool in modern software design.
    </p>
</div>
